---
title: '[数据结构与算法]题练簇'
date: 2024-02-22 11:42:31
tags: [题练簇,cpp,数据结构与算法]
categories: 
- [CS,cpp,题练簇]
---
# From Leetcode

---
## unordered_map & hash

[49 字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/)  
**题解**    
先创建一个哈希表，遍历strs，将遍历得到的每个字符串排序，这样如“abcb”，“acbb”之类的字符串排序后都是“abbc”，在哈希表“abbc”这个key下储存了“abcb”，“acbb”这两个字符串 再遍历一遍哈希表，将哈希表中的vector添加进答案中


``` cpp Code mark:1
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> umap;
        for(auto &x :strs){
            string str = x;
            sort(str.begin(),str.end());
            umap[str].push_back(x);
        }
        vector<vector<string>> ret;
        for(auto [key,value]:umap){ 
            ret.push_back(value);
        }
        //for(auto x : umap){
        //    ret.push_back(x.second);
        //};
        return ret;
    }
};
```
---
##  hash & sudoku


[36 有效的数独](https://leetcode.cn/problems/valid-sudoku/description/)  
**题解**  
```cpp 暴力 mark:1
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int row[9][10] = {0};// 哈希表存储每一行的每个数是否出现过，默认初始情况下，每一行每一个数都没有出现过
        // 整个board有9行，第二维的维数10是为了让下标有9，和数独中的数字9对应。
        int col[9][10] = {0};// 存储每一列的每个数是否出现过，默认初始情况下，每一列的每一个数都没有出现过
        int box[9][10] = {0};// 存储每一个box的每个数是否出现过，默认初始情况下，在每个box中，每个数都没有出现过。整个board有9个box。
        for(int i=0; i<9; i++){
            for(int j = 0; j<9; j++){
                // 遍历到第i行第j列的那个数,我们要判断这个数在其所在的行有没有出现过，
                // 同时判断这个数在其所在的列有没有出现过
                // 同时判断这个数在其所在的box中有没有出现过
                if(board[i][j] == '.') continue;
                int curNumber = board[i][j]-'0';
                if(row[i][curNumber]) return false; 
                if(col[j][curNumber]) return false;
                if(box[j/3 + (i/3)*3][curNumber]) return false;
                row[i][curNumber] = 1;// 之前都没出现过，现在出现了，就给它置为1，下次再遇见就能够直接返回false了。
                col[j][curNumber] = 1;
                box[j/3 + (i/3)*3][curNumber] = 1;
            }
        }
        return true;
    }
};
```
**位运算**  
[【宫水三叶】一题三解 :「哈希表」&「数组」&「位运算」](https://leetcode.cn/problems/valid-sudoku/solutions/1002073/gong-shui-san-xie-yi-ti-san-jie-ha-xi-bi-ssxp/)  

更进一步，我们可以使用一个 `intintint` 来记录 某行/某列/某个小方块 的数值填入情况：使用从低位开始的 `[1,9]` 位来记录该数值是否已被填入。  

例如 `(...111000111.)2`
​
  代表数值 `[1,3]` 和 `[7,9]` 均被填入。
``` java mark:1
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[] row = new int[10], col = new int[10], area = new int[10];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c == '.') continue;
                int u = c - '0';
                int idx = i / 3 * 3 + j / 3;
                if ((((row[i] >> u) & 1) == 1) || (((col[j] >> u) & 1) == 1) || (((area[idx] >> u) & 1) == 1)) return false;
                row[i] |= (1 << u);
                col[j] |= (1 << u);
                area[idx] |= (1 << u);
            }
        }
        return true;
    }
}
```
时间复杂度：在固定 `9∗9` 的问题里，计算量不随数据变化而变化。复杂度为 `O(1)` 
空间复杂度：在固定 `9∗9` 的问题里，存储空间不随数据变化而变化。复杂度为 `O(1)`  

---
## hash & unordered_set

[128 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-100-liked)  
**题解**  
[最长连续序列 | 哈希 | 代码简洁易懂 【c++/java版】](https://leetcode.cn/problems/longest-consecutive-sequence/solutions/925733/ha-xi-zui-qing-xi-yi-dong-de-jiang-jie-c-xpnr/?envType=study-plan-v2&envId=top-100-liked)  
``` cpp mark:1
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> hash;
        for( auto x : nums) hash.insert(x);
        int res  = 0;
        for(auto x : hash){
            if(!hash.count(x-1)){
                int y = x;
                while(hash.count(y+1))y++;
                res = max(res,y-x +1);
            }
        }
        return res;
    }
};
```
---
## hash & unordered_map & sliding window
[438 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/?envType=study-plan-v2&envId=top-100-liked)  
**题解**  
[vector数组+移动窗口](https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/960733/vectorshu-zu-yi-dong-chuang-kou-by-ai-ru-ovsu/?envType=study-plan-v2&envId=top-100-liked)  
```cpp mark:1
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> result;
        int m=s.size();
        int n=p.size();
        if(m<n) return result;
        vector<int> win(26,0); //定义窗口字母统计数组
        vector<int> st(26,0);
        for(int i=0;i<n;i++) st[p[i]-'a']++;
        int slow=0;
        for(int fast=0;fast<m;fast++){
            win[s[fast]-'a']++;
            if(fast>=n){win[s[slow]-'a']--; slow++;} //达到p的大小后，每次fast和slow同时移动
            if(st==win){
                result.push_back(slow);
            }
        }
        return result;
    }
};
```
**个人代码**  
以以上代码思路，以unordered_map作容器  
对比之下，vector作容器可能更高效  
```cpp mark:1
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        unordered_map<char,int> hash;
        vector<int> res;
        int plen = p.size();
        int slen = s.size();
        if(slen<plen)return res;
        unordered_map<char,int> cmpHash;//作窗口
        for(auto x : p)hash[x]++;   //得到固定的哈希表
        int left =0;
        for(int right = 0;right < slen;right++){
            if(hash.count(s[right])== 0){ //略过不在固定哈希表中的元素
                cmpHash.clear();        //同时清空窗口
                left = right+1;         //left记录下一位
                continue;
            }
            cmpHash[s[right]]++;        //插入和计数
            if(right-left >= plen){         //right从0开始开窗口
                if(!--cmpHash[s[left]])cmpHash.erase(s[left]);
                left++;
            }
            if(cmpHash == hash)res.push_back(left);
        }
        return res; 
    }
};
```
---
## unordered_map & hash & prefix sum

[560 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)  
**题解**   
``` cpp mark:1
class Solution {
public:
    int subarraySum_3(vector<int>& nums, int k) {
        int result = 0, preSumRight = 0;
        unordered_map<int, int> hashMap;
        // 为什么要有此初始化？
        // 主要是当数组只有一个元素时，历史前缀和数据(也就是hash表)是空的，因为还未来得及构建
        // 当数组中这个元素正好等于k时，需要hash表中保存的历史前缀和数据有一个key=0的数据
        // 如果数组中这个元素不等于k时，是不影响结果的
        hashMap[0] = 1;
        for (int i = 0; i < nums.size(); ++i) {
            // 算一下当前前缀和
            preSumRight += nums[i];
            // 下面是前缀和的理解核心：
            // 假设有一个区间[left, right], 该区间上元素和为k
            // 那么就有:
            // ([0,right]元素之和)  减去  ([0,left] 元素之和) 等于 (k)
            // 转换一下就是:
            // ([0,right]元素之和)  减去  (k)  等于  ([0,left] 元素之和)
            // ([0,right]元素之和) 就是
            //      每次循环时立刻就能算出来的当前前缀和，姑且叫为 preSumRight
            // ([0,left] 元素之和) 就是
            //      存在hash表里面的历史前缀和数据, 
            //      key是历史前缀和数据姑且叫为 preSumLeft, value是出现的次数
            // 可以得到：
            int preSumLeft = preSumRight - k;
            if (hashMap.count(preSumLeft) == 1) {
                result += hashMap[preSumLeft]; // goto #cypress_1
            }
            // 将当前前缀和存储hash表
            hashMap[preSumRight]++;
        }
        return result;
    }
    //  #cypress_1
    //  ques:为什么是result+= hashMap[preSumLeft] 而不是直接result++呢？
    //  2024/2/6 ans: 在这个问题之前，可以再考虑 “为什么使用 unordered_map 而不是 unordered_set”
    //              unordered_map的first记录前缀和，second记录对应前缀和的个数，所以最开始有 hashMap[0] = 1 这个初始化
    //              unordered_set 不允许重复，虽然两者的count非0即1，均适应if的判断
    //              但是unordered_set只能使用res++，不能使用res+=hashSet[preSumLeft]
    //              再回到最开始的问题，前缀和的个数是有必要的，配合如上的说明简单思考一下就可以得出该结论
};
```
---